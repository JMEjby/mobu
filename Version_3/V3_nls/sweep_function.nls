to sweep [ param-combo ]
  ; Initialize sweep by clearing everything and setting up parameter ranges
  clear-all
  set sweeping? true

  ; setting up parameters according to sweep-params and asks for user approval
  ; Define variables for custom parameters
  let aggregation-methods [ "average" "product" ]
  let signal-representations [ "binary" "categorical-dirichlet" ]
  let leader-influence-values ( range 0 101 5 )  ; Relative leader influence from 0% to 100% in steps of 5
  let runs-per-combo 5
  let m-sat-values 0
  let n-agent-values 0

  ; define ranges based on param-combo
  ( ifelse param-combo = "focused-population" [
    set m-sat-values ( range 5 96 5 )  ; Movement saturation from 5% to 95% in steps of 5
    set n-agent-values [ 100 1000 ]  ; Different population sizes to test
  ] param-combo = "test-range" [
    set m-sat-values ( range 5 96 5 )  ; Movement saturation from 5% to 95% in steps of 5
    set n-agent-values [ 25 50 100 ]  ; Different population sizes to test
  ] param-combo = "custom-all" [
    ; Get custom parameters from user
    let m-sat-input user-input "Enter movement saturation values (e.g., 5 15 25 35 45 55 65 75 85 95):"
    let n-agent-input user-input "Enter population sizes (e.g., 25 50 100 250 500 1000):"
    let agg-method-input user-input "Enter aggregation methods (e.g., 0 = average 1 = product):"
    let signal-rep-input user-input "Enter signal representations (e.g., 0 = binary 1 = categorical-dirichlet):"
    let leader-influence-input user-input "Enter relative leader influence values (e.g., 0 25 50 75 100):"
    let runs-input user-input "Enter number of runs per combination:"

    ; Parse the inputs
    set m-sat-values read-from-string (word "[" m-sat-input "]")
    set n-agent-values read-from-string (word "[" n-agent-input "]")
    set aggregation-methods map [ i -> ( ifelse-value i = 0 [ "average" ] [ "product" ] ) ] read-from-string (word "[" agg-method-input "]")
    set signal-representations map [i -> ifelse-value i = 1 [ "categorical-dirichlet" ] [ "binary" ] ] read-from-string (word "[" signal-rep-input "]")
    set leader-influence-values read-from-string (word "[" leader-influence-input "]")
    set runs-per-combo read-from-string runs-input
  ] [
    ; Default case (full-range)
    set m-sat-values ( range 5 96 5 )  ; Movement saturation from 5% to 95% in steps of 5
    set n-agent-values [ 25 50 100 250 500 1000 ]  ; Different population sizes to test
    ]
  )

  ; Check with user before starting the sweep
  let total-combinations (length m-sat-values * length n-agent-values * length aggregation-methods * length signal-representations * length leader-influence-values * runs-per-combo)
  let proceed? user-yes-or-no? (word
    "Start parameter sweep with the following settings?\n\n"
    "Movement saturation: " m-sat-values "\n"
    "Population sizes: " n-agent-values "\n"
    "Aggregation methods: " aggregation-methods "\n"
    "Signal representations: " signal-representations "\n"
    "Relative leader influence: " leader-influence-values "\n"
    "Runs per combination: " runs-per-combo "\n"
    "Total simulations: " total-combinations "\n\n"
    "This may take several minutes. Continue?" )

  ; Exit if user chooses not proceed
  if not proceed? [
    user-message "Sweep cancelled."
    stop
  ]

  ; Clear any existing plot data to start fresh
  clear-all-plots

  ; Define distinct colors for each combination
  let pen-colors [ red blue green orange violet cyan magenta yellow brown pink ]
  let color-index 0

  ; Initialize data collection lists for R plotting
  let all-data []  ; Will store: [n-agents movement-saturation relative-leader-influence conversion-rate run-id aggregation-method signal-representation]

  ; Loop through each population size
  foreach n-agent-values [ n ->

    ; Loop through each aggregation method
    foreach aggregation-methods [ agg-method ->

      ; Loop through each signal representation
      foreach signal-representations [ sig-rep ->

        ; Loop through each relative leader influence level
        foreach leader-influence-values [ leader-inf ->

          ; Create a pen name
          let pen-name (word "n=" n " " agg-method " " sig-rep " leader=" leader-inf)

          ; Create a pen for individual simulation runs
          set-current-plot "Conversion Rate by Movement Saturation"
          create-temporary-plot-pen pen-name
          set-plot-pen-color item (color-index mod length pen-colors) pen-colors

          ; Create a pen for means in the separate means plot
          set-current-plot "Mean Conversion Rates"
          create-temporary-plot-pen pen-name
          set-plot-pen-color item (color-index mod length pen-colors) pen-colors

          set color-index color-index + 1

          ; Loop through each movement saturation level
          foreach m-sat-values [m ->
            ; Set parameters for this combination
            set n-agents n
            set movement-saturation m
            set aggregation-method agg-method
            set signal-representation sig-rep
            set relative-leader-influence leader-inf

            let cr-values []  ; List to store conversion rates from multiple runs

            ; Switch to individual runs pen for plotting
            set-current-plot "Conversion Rate by Movement Saturation"
            set-current-plot-pen pen-name

            ; Run the simulation multiple times with the same parameters
            let run-id 0
            repeat runs-per-combo [
              set run-id run-id + 1
              setup  ; Initialize model with current parameters
              go     ; Run one simulation step

              plotxy m conversion-rate  ; Plot individual result
              set cr-values lput conversion-rate cr-values  ; Add to list for mean calculation

              ; count number of converted turtles by profile
              let converted-A count outsiders with [ recruited? and value-profile = "A" ]
              let converted-B count outsiders with [ recruited? and value-profile = "B" ]
              let converted-C count outsiders with [ recruited? and value-profile = "C" ]
              let converted-D count outsiders with [ recruited? and value-profile = "D" ]
              let converted-E count outsiders with [ recruited? and value-profile = "E" ]

              ; total count by profile
              let total-A count outsiders with [ value-profile = "A" ]
              let total-B count outsiders with [ value-profile = "B" ]
              let total-C count outsiders with [ value-profile = "C" ]
              let total-D count outsiders with [ value-profile = "D" ]
              let total-E count outsiders with [ value-profile = "E" ]

               ; convertion rates by profile
              let conversion-rate-A 0
              let conversion-rate-B 0
              let conversion-rate-C 0
              let conversion-rate-D 0
              let conversion-rate-E 0
              
              carefully[ set conversion-rate-A converted-A / total-A ][ set conversion-rate-A "NA" ]
              carefully[ set conversion-rate-B converted-B / total-B ][ set conversion-rate-B "NA" ]
              carefully[ set conversion-rate-C converted-C / total-C ][ set conversion-rate-C "NA" ]
              carefully[ set conversion-rate-D converted-D / total-D ][ set conversion-rate-D "NA" ]
              carefully[ set conversion-rate-E converted-E / total-E ][ set conversion-rate-E "NA" ]

              ; Store data for R plotting: [n-agents movement-saturation relative-leader-influence conversion-rate run-id aggregation-method signal-representation]
              set all-data lput ( list run-id n m leader-inf agg-method sig-rep conversion-rate
                conversion-rate-A conversion-rate-B conversion-rate-C conversion-rate-D conversion-rate-E
                converted-A converted-B converted-C converted-D converted-E
                total-A total-B total-C total-D total-E ) all-data
            ]

            ; Calculate mean of the runs and plot in the means plot
            let mean-cr mean cr-values
            set-current-plot "Mean Conversion Rates"
            set-current-plot-pen pen-name
            plotxy m mean-cr
          ]

          ; Progress indicator for this combination
          print ( word "Completed n-agents = " n ", method = " agg-method ", signal-rep = " sig-rep ", leader-influence = " leader-inf)
        ]
      ]
    ]
  ]

  ; Reset sweep mode
  set sweeping? false

  export-sweep-data all-data
  user-message "Sweep complete! All parameter combinations have been tested. Data exported to 'sweep_data.csv'."
end

; Function to export data as CSV for external plotting
to export-sweep-data [ data ]
  ; Create headers
  let headers (list "run_id" "n_agents" "movement_saturation" "relative_leader_influence""aggregation_method" "signal_representation""conversion_rate"
    "conversion_rate_A" "conversion_rate_B" "conversion_rate_C" "conversion_rate_D" "conversion_rate_E"
    "converted_A" "converted_B""converted_C" "converted_D" "converted_E"
    "total_A" "total_B" "total_C" "total_D" "total_E")
  
  ; Combine headers with data
  let csv-data fput headers data

  ; Export to CSV
  csv:to-file "sweep_data.csv" csv-data

  print "Data exported to sweep_data.csv"
end